'2001_03_03-5.bsx - v5 has ramp & lift seek tested. 

'IMPORTANT: now assumes ramp and lift sensors are wired the direction I like:
'lift is larger up, ramp is larger down.. so they move directly proportional
'rather than inverse. 

'2001_02_28-3.bsx - cleanup.. drafting auto seek position stuff. 
'(moved jog routines away into memory bank 1)

'2001_02_18-5.bsx - the version loaded in the robot as shipped and
'  tested in the wildstang regional. 

'2001_03_03_08-2 - Working code stuffs at the beginning of the practice rounds

'2001_03_08-3 - Buttons remapper on the  button box

'2001_03_08_5 - AUTO DRIVE ALIGN ----DOES NOT EXIST----

'2001_03_26_1 - SDT, Fix ramp oscillation, slack always on the same side of the ramp chain

'2001_04_04_1 - SDT, Added "real slow" speed for seeking to ramp positions in the air

'2001_04_05_1 - SDT, Changed RAMP_UP position

'-- INPUT notes --

'p1_x/y =	drive 
'p2_sw_top	servo control, pressed=on


'-- OUTPUT notes --

'PWMs
'1  <broken>
'2  red	front left wheel
'3  purple	back left wheel
'4  brown
'5  orange  doors 
'6  yellow
'7  grey    lift 
'8  green	tail 
'9  blue	back right wheel
'10 white	front right wheel
'11
'12
'13
'14
'15		servo 



'----------

'add sections for each control (blanks) 
'left & right steps. 


'k: break into neater subroutines. 
'k: just demo that this works for a single stick drive.. no other IO. 

' WildStang Default code un-aliasing solution using scratch pad ram. 
' Keith Feb 2000
' Using PUT/GET scratchpad ram (& RUN to 2nd EEPROM regions), maximizes
' the amount of memory available for user code and reduces the amount
' of stuff you have to look at to modify variable use. 
'
' More than anything, this reduces the confusing and sometimes
' dangerous problem of aliasing (reusing the same memory for variables
' with different purposes and meanings).  Aliasing often means that
' when a new variable is needed, the entire code must be reviewed to
' check for interfering side-effects, making it difficult for multiple 
' programmers to share code or make safe changes quickly. 
'
' This code is provided as an example only. 
' It may be freely used by other teams, but it is expected that
' any users are familiar with the system and are responsible for
' reviewing the code and correcting any problems.  Read the default
' code before trying to interpret this, so you can see what the
' changes are and how they are different. 
'
' This method effectively gives you up to 63 ram variables that
' don't interfere with each other when used as follows: 
'
' To use:
' 1- declare an "s_" constant to be the scratchpad location
'    for each unique variable you want to have.
' 2- PUT all the input values into secondary memory just after Serin
' 3- GET any values afresh before use.
' 4- PUT any values away after any computation.
' 5- GET all output values just before Serout. 
'
' There is some speed penalty in doing all these writes, so make 
' sure you don't overdo it. 
'(because binary IO, buttons/switches, are so memory efficient, you
' can just be careful and not alias these, but whole bytes are scarce
' so PUT all 'analog' values.)
'[also have a separate timesliced debug section with separate GETs as needed.]

'Note that if you get even more desperate for memory than the scratchpad
'ram provides for, you can always write vars to EEPROM.. but it's slow so
'should probably only be used for operations that execute 1 out of N loops
'(possibly some debug computations...) also note that EEPROM is not shared
'between multiple programs, branched to via 'RUN'. 

'----------------------------------------
' PROGRAM:    2000 Default Code RevNC.bsx
' Written by: Innovation First, Inc.
' Date:       12/28/99
'
' Define BS2-SX Project Files
'
' {xx$STAMP BS2SX, xx2001jog_routines.bsx}
' {$STAMP BS2SX}


DEBUG_ENABLE CON 0  'set to 1 to print debug stuff (slow)

'=============================================================================
'constants for Scratchpad ram locations [0-62] (63 reserved)

'(I just reserved these in the order they come in the serin stream)

s_oi_swA	CON	0	
s_oi_swB	CON	1
s_rc_swA	CON	2
s_rc_swB	CON	3
s_p2_x	CON	4
s_p1_x	CON	5	'stored' value of p1_x
s_p4_x	CON	6
s_p3_x	CON	7
s_PB_mode	CON	8
s_packet_num CON	9
s_sensor1	CON	10	
s_sensor2	CON	11	
s_p2_y	CON	12	
s_p1_y	CON	13	
s_sensor3	CON	14	
s_sensor4	CON	15	
s_p4_y	CON	16	
s_p3_y	CON	17	
s_sensor5	CON	18	
s_sensor6	CON	19	
s_p2_wheel	CON	20	
s_p1_wheel	CON	21	
s_sensor7	CON	22	
s_sensor8	CON	23	
s_p4_wheel	CON	24	
s_p3_wheel	CON	25	
s_p2_aux	CON	26	
s_p1_aux	CON	27	
s_p4_aux	CON	28	
s_p3_aux	CON	29	
s_delta_t	CON	30	
s_res01	CON	31	
'(...end of possible serin inputs.  continue now, with outputs and stuff
' like output variables... I just reserved these in the order the go in
' the serout stream)
'
s_pwm1	CON	32	'stored' value for pwm1
s_relayA	CON	33
s_pwm2	CON	34
s_relayB	CON	35
s_pwm3	CON	36
s_pwm4	CON	37
s_pwm5	CON	38
s_pwm6	CON	39
s_pwm7	CON	40
s_pwm8	CON	41
s_pwm9	CON	42
s_pwm10	CON	43
s_pwm11	CON	44
s_pwm12	CON	45
s_pwm13	CON	46
s_pwm14	CON	47
s_pwm15	CON	48
s_pwm16	CON	49
s_ramp_seek CON   50  'the ramp mode 
s_lift_seek CON   51  'the lift mode 
'
's_rampAvg	CON	62

'(...end of serouts... add on any other storage names up to 62 that
' are useful) etc. etc...
'

'========== DECLARE VARIABLES ================================================
'=============================================================================
'  Below is a list of declared input and output variables.  Comment or un-comment
'  the variables as needed.  Declare any additional variables required in
'  your main program loop.  Note that you may only use 26 total variables.


'---------- Operator Interface (OI) - Analog Inputs --------------------------
'Show all vars and all their aliases: 1st line of a group is
'declaration (up to 26 of them) and rest of the group are all
'the things alised to it (basically meaning that you can't
'use them at the same time and expect them to be independent).
'For example, don't alias any of the serin inputs together, or
'any of the serout outputs, because they all need to be free
'at the same time. 

tmp1        VAR byte	'two vars which are kept independent of anything else
tmp2        VAR byte	'so they can be used _with_ anything else. 
'do not alias tmp1 or tmp2. 

p1_x		VAR byte   'Port 1, X-axis on Joystick
'pwm1		VAR p1_x 
pwm3	      VAR p1_x 
'(This association is not to suggest that these
' variables be used together.  In fact since they are aliased to each other,
' they should never be used as part of the same section of code.  They are
' just organized this way to show that all the inputs are seperate from
' each other, and all the outputs from other outputs.) 

' You must still be careful not to mix input and output vars in the
' same region of code, for example: 
'
' pwm2 = p1_x / 2  ' could be confusing, because it has the side effect
' of overwriting p2_x (aliased to pwm2.. although p2_x could be re-read
' from s_p2_x if needed).  The recommended way of writing that would be: 
'
' tmp1 = p1_x / 2
' PUT s_pwm2, tmp1  '(pwm2 value is safely stored)

p2_x	VAR	byte	'Port 2, X-axis on Joystick
pwm2	VAR	p2_x
left_wheel VAR pwm2 

'**p3_x	VAR	byte	'Port 3, X-axis on Joystick

'**p4_x	VAR	byte	'Port 4, X-axis on Joystick
'pwm4	VAR	p4_x

p1_y	VAR	byte	'Port 1, Y-axis on Joystick
pwm5	VAR	p1_y

p2_y	VAR	byte	'Port 2, Y-axis on Joystick
pwm6	VAR	p2_y

'**p3_y	VAR	byte	'Port 3, Y-axis on Joystick

pwm7	VAR	byte

'**p4_y	VAR	byte	'Port 4, Y-axis on Joystick

pwm8	VAR	byte

p1_wheel	VAR	byte	'Port 1, Wheel on Joystick
pwm9		VAR	p1_wheel
right_wheel VAR pwm9 

p2_wheel	VAR	byte	'Port 2, Wheel on Joystick
pwm10		VAR	p2_wheel

'**p3_wheel	VAR	byte	'Port 3, Wheel on Joystick

pwm11		VAR	byte

'**p4_wheel	VAR	byte	'Port 4, Wheel on Joystick

pwm12		VAR	byte

p1_aux	VAR	byte	'Port 1, Aux on Joystick
pwm13		VAR	p1_aux

p2_aux	VAR	byte	'Port 2, Aux on Joystick
pwm14		VAR	p2_aux

p3_aux	VAR	byte	'Port 3, Aux on Joystick
pwm15		VAR	p3_aux

p4_aux	VAR	byte	'Port 4, Aux on Joystick
pwm16		VAR	p4_aux


'---------- Operator Interface - Digital Inputs ------------------------------
'K: probably best NOT to alias digital inputs and outputs since
' they use memory so efficiently.  It will reduce the need to
' PUT and GET them...

oi_swA	VAR byte	'OI Digital Switch Inputs 1 thru 8
oi_swB	VAR byte	'OI Digital Switch Inputs 9 thru 16
'do not alias these. 


'---------- Robot Controller (RC) - Analog Inputs ----------------------------

sensor1	VAR byte	'RC Analog Input 1, connector pin 2
sensor2	VAR byte	'RC Analog Input 2, connector pin 16
sensor3	VAR byte	'RC Analog Input 3, connector pin 5
sensor4	VAR byte	'RC Analog Input 4, connector pin 19
'sensor5	VAR byte	'RC Analog Input 5, connector pin 8
'sensor6	VAR byte	'RC Analog Input 6, connector pin 22
'sensor7	VAR byte	'RC Analog Input 7, connector pin 11
'bat_volt	VAR byte	'RC Analog Input 8, hardwired to the Battery
				'Vin = ((4.7/14.7)* Battery voltage)-0.4
				'Binary Battery Voltage = (Vin/5.0 V)*255


'---------- Robot Controller - Digital Inputs --------------------------------

rc_swA	VAR byte	'RC Digital Inputs 1 thru 8
rc_swB	VAR byte	'RC Digital Inputs 9 thru 16
'do not alias these. 


'---------- Robot Controller - Digital Outputs -------------------------------

relayA	VAR byte
relayB	VAR byte
'do not alias these (unless code is carefully reviewed for correct use etc.)


'---------- Misc. ------------------------------------------------------------

'**PB_mode	VAR byte
'packet_num	VAR byte
'delta_t	VAR byte


'JogReady    VAR bit 


'========== DEFINE ALIASES ===================================================
'=============================================================================
'  Aliases are variables which are sub-divisions of variables defined
'  above.  Aliases don't require any additional RAM.


'---------- Aliases for each OI switch input ---------------------------------
'  Below are aliases for the digital inputs located on the Operator Interface.
'  Ports 1 & 3 have their inputs duplicated in ports 4 & 2 respectively.  The 
'  inputs from ports 1 & 3 may be disabled via the 'Disable' dip switch 
'  located on the Operator Interface.  See Users Manual for details.

p1_sw_trig	VAR oi_swA.bit0	'Joystick Trigger Button,	same as Port4 pin5 
p1_sw_top	VAR oi_swA.bit1	'Joystick Top Button,		same as Port4 pin8
p1_sw_aux1	VAR oi_swA.bit2	'Aux input,				same as Port4 pin9
p1_sw_aux2	VAR oi_swA.bit3	'Aux input,				same as Port4 pin15

p3_sw_trig	VAR oi_swA.bit4	'Joystick Trigger Button,	same as Port2 pin5 
p3_sw_top	VAR oi_swA.bit5	'Joystick Top Button,		same as Port2 pin8
p3_sw_aux1	VAR oi_swA.bit6	'Aux input,				same as Port2 pin9
p3_sw_aux2	VAR oi_swA.bit7	'Aux input,				same as Port2 pin15

p2_sw_trig	VAR oi_swB.bit0	'Joystick Trigger Button
p2_sw_top	VAR oi_swB.bit1	'Joystick Top Button
p2_sw_aux1	VAR oi_swB.bit2	'Aux input / TRIGGER on y-cable config 
p2_sw_aux2	VAR oi_swB.bit3	'Aux input / TOP on y-cable config 

p4_sw_trig	VAR oi_swB.bit4	'Joystick Trigger Button
p4_sw_top	VAR oi_swB.bit5	'Joystick Top Button
p4_sw_aux1	VAR oi_swB.bit6	'Aux input
p4_sw_aux2	VAR oi_swB.bit7	'Aux input


'---------- Aliases for each RC switch input ---------------------------------
'  Below are aliases for the digital inputs located on the Robot Controller.

rc_sw1	VAR rc_swA.bit0
rc_sw2	VAR rc_swA.bit1
rc_sw3	VAR rc_swA.bit2
rc_sw4	VAR rc_swA.bit3
rc_sw5	VAR rc_swA.bit4
rc_sw6	VAR rc_swA.bit5
rc_sw7	VAR rc_swA.bit6
rc_sw8	VAR rc_swA.bit7
rc_sw9	VAR rc_swB.bit0
rc_sw10	VAR rc_swB.bit1
rc_sw11	VAR rc_swB.bit2
rc_sw12	VAR rc_swB.bit3
rc_sw13	VAR rc_swB.bit4
rc_sw14	VAR rc_swB.bit5
rc_sw15	VAR rc_swB.bit6
rc_sw16	VAR rc_swB.bit7


'---------- Aliases for each RC Relay outputs ---------------------------------
'  Below are aliases for the relay outputs located on the Robot Controller.

relay1_fwd	VAR RelayA.bit0
relay1_rev	VAR RelayA.bit1
relay2_fwd	VAR RelayA.bit2
relay2_rev	VAR RelayA.bit3
relay3_fwd	VAR RelayA.bit4
relay3_rev	VAR RelayA.bit5
relay4_fwd	VAR RelayA.bit6
relay4_rev	VAR RelayA.bit7

relay5_fwd	VAR RelayB.bit0
relay5_rev	VAR RelayB.bit1
relay6_fwd	VAR RelayB.bit2
relay6_rev	VAR RelayB.bit3
relay7_fwd	VAR RelayB.bit4
relay7_rev	VAR RelayB.bit5
relay8_fwd	VAR RelayB.bit6
relay8_rev	VAR RelayB.bit7


'---------- Aliases for the Pbasic Mode Byte (PB_mode) -----------------------
'  The last bit of the PB_mode byte (aliased as comp_mode) indicates the status
'  of the Competition Control, either Enabled or Disabled.  This indicates the
'  starting and stopping of rounds at the competitions.  Comp_mode is the same
'  as the "Disabled" LED on the Operator Interface.
'  Comp_mode = 1 for Enabled, 0 for Disabled.

'comp_mode		VAR PB_mode.bit7




'========= DEFINE CONSTANTS FOR INITIALIZATION ===============================
'=============================================================================
'  The initialization code is used to select the input data used by PBASIC.
'  The Master micro-processor (uP) sends the data you select to the BS2SX
'  PBASIC uP.  You may select up to 26 constants, corresponding
'  to 26 variables, from the 32 available to you.  Make sure that you have 
'  variables for all the bytes recieved in the serin command.
'
'  The constants below have a "c_" prefix, as compared to the variables that 
'  they will represent.
'
'  Set the Constants below to 1 for each data byte you want to recieve.
'  Set the Constants below to 0 for the unneeded data bytes.


'---------- Set the Initialization constants you want to read ----------------

c_p1_y		CON	1
c_p2_y		CON	1
c_p3_y		CON	0
c_p4_y		CON	0

c_p1_x		CON	1
c_p2_x		CON	1
c_p3_x		CON	0
c_p4_x		CON	0

c_p1_wheel		CON	1
c_p2_wheel		CON	1
c_p3_wheel		CON	0
c_p4_wheel		CON	0

c_p1_aux		CON	0
c_p2_aux		CON	1
c_p3_aux		CON	0
c_p4_aux		CON	0

c_oi_swA		CON	1
c_oi_swB		CON	1

c_sensor1		CON	1
c_sensor2		CON	1
c_sensor3		CON	1
c_sensor4		CON	1
c_sensor5		CON	0
c_sensor6		CON	0
c_sensor7		CON	0
c_batt_volt		CON	0

c_rc_swA		CON	1
c_rc_swB		CON	1

c_delta_t		CON	0
c_PB_mode		CON	0
c_packet_num	CON	0
c_res01		CON	0


'---------- Initialization Constant VOLTAGE - USER DEFINED -------------------
'  This is the 'Low Battery' detect voltage.  The 'Low Battery' LED will
'  blink when the voltage drops below this value.
'  Basically set VOLTAGE = INT ((DESIRED FLASH VOLTAGE + 0.4) * 16.3)
'  Example, for a 10 Volt trigger, set Voltage eq 170.

dataInitVolt	CON 153	'9.0 Volts




'========== DEFINE CONSTANTS (DO NOT CHANGE) =================================
'=============================================================================
' Baud rate for communications with User CPU
OUTBAUD	CON	20	' (62500, 8N1, Noninverted)
INBAUD	CON	20	' (62500, 8N1, Noninverted)

USERCPU	CON 4
FPIN		CON 1
COMA		CON 1
COMB		CON 2
COMC		CON 3


'========== User Constants =================================

NO_PWM CON 127  'stop value.. unused pwm. 

DRIVE_DEADZONE      CON  5   'joystick: drive 

DRIVE_SCL CON 50  'turbo drive speed reduction (percent) [e.g. 50]
DRIVE_CON CON 64  '128 * reduction percent [e.g. 64] 

'=====================================================
'========= Autoalign to bridge =======================
'=====================================================
ALIGN_REVERSE_SPEED CON 127-10
ALIGN_FORWARD_SPEED CON 127+15
ENABLE_AUTOALIGN_THRESHHOLD CON 240  'Pin ramp joystick past this X value to enable (left)

'=====================================================
'========= Disable Software Stops ====================
'=====================================================
DISABLE_SOFTARE_THRESHOLD CON 20  'Pin ramp joy past this X value to disable SW stops (right)

'=====================================================
'========= Doors/Snowplow Defines ====================
'=====================================================
DOORS_OPEN_SPEED   CON 127-55
DOORS_CLOSE_SPEED CON 127+55

'=====================================================
'============== Ramp/Tail Defines ====================
'=====================================================
'sdt: The ramp has three speeds...fast, slow and real slow.  The ramp will run in fast mode
'     when outside of the RAMP_SLOW_SPEED_ZONE.  Once in the ramp slow speed zone it will 
'     run slow.  The ramp will run real slow if in the RAMP_SLOW_SPEED_ZONE and seeking to
'     a position that is in the air.  Without the added force of trying to lift the robot
'     the ramp will simply oscillate.  But, real slow cannot be used when lifting the
'     robot because it is not strong enough so it is only used for positions in the air (UP).
RAMP_UP_SPEED_FAST        CON 127-75 
RAMP_UP_SPEED_SLOW        CON 127-50
RAMP_DOWN_SPEED_FAST      CON 127+100 
RAMP_DOWN_SPEED_SLOW      CON 127+50
RAMP_DOWN_SPEED_REAL_SLOW CON 127+15  'Real slow for positions in the air

'sdt: There is a different zone from the top than the bottom because currently I always want
'     to overshoot the target when bringing the tail up.  This will ensure that the slack
'     on the chail will always be on the same side of the sprocket.  This will gaurantee
'     the tail will respond immediately when asked to move down.
RAMP_UP_SLOW_SPEED_ZONE   CON 0   'Within this many ticks of target go slow...when going UP
RAMP_DOWN_SLOW_SPEED_ZONE CON 20  'Within this many ticks of target go slow...when going DOWN

'Deadzone in the ramp joystick
RAMP_JOY_DEADZONE   CON  10  'joystick: tail 

's_ramp_seek is the 'mode', which is either the angle, or 0 for manual. 
'(calibrated for test bot 3/3) 
RAMP_ARCH_SEEK  CON  156                     '159 Fully down, arches the robot
RAMP_LEVEL_SEEK CON  RAMP_ARCH_SEEK - 9      '150 Level
RAMP_ARCH_ZONE  CON  RAMP_LEVEL_SEEK - 2     '149 Below here will cause auto-arch with lift
RAMP_UP_SEEK    CON  RAMP_ARCH_SEEK - 22     '134 Used for snow plow and holding a robot on us
RAMP_UP_LIMIT   CON  RAMP_ARCH_SEEK - 114    '45  Upper limit to move ramp manually 
RAMP_NO_SEEK    CON  0   'manual mode.. special value. 

'Deadzone around the ramp autoseek positions
RAMP_DEADZONE CON 1  'feedback control 

'================================================
'============== Lift Defines ====================
'================================================
's_lift_seek is the 'mode', which is either the height, or 0 or 1 for manual(s). 
'(calibrated for practice bot 3/3) 
LIFT_TOP           CON  255  'value when bridge is fully lifted 
LIFT_READY_SEEK    CON  250 
LIFT_ARCH_POINT    CON  70  'only used when we have a single threshold arch point 
LIFT_BALANCE_SEEK  CON  30 
LIFT_DOWN_SEEK     CON  15   'not a seek, just for pinning freefall
LIFT_FREEFALL      CON  1    'freefall mode.. special value. 
LIFT_NO_SEEK       CON  0    'manual mode.. special value. 

LIFT_UP_SPEED   CON 254
LIFT_DOWN_SPEED CON 1
LIFT_FREEFALL_SPEED CON 1  'down fast




'========== MAIN PROGRAM =====================================================
'=============================================================================

'---------- Input & Output Declarations --------------------------------------

Output	COMB
Input		COMA
Input		COMC

Output	7	'define Basic Run LED on RC => out7

Output      8	'define Robot Feedback LED => out8	=> PWM1 Green
Output      9	'define Robot Feedback LED => out9	=> PWM1 Red
Output      10	'define Robot Feedback LED => out10	=> PWM2 Green
Output      11	'define Robot Feedback LED => out11 => PWM2 Red
Output      12	'define Robot Feedback LED => out12 => Relay1 Red
Output      13	'define Robot Feedback LED => out13 => Relay1 Green
Output      14	'define Robot Feedback LED => out14 => Relay2 Red
Output      15	'define Robot Feedback LED => out15 => Relay2 Green


'---------- Initialize Inputs & Outputs --------------------------------------

Out7  = 1		'Basic Run LED on RC
Out8  = 0		'PWM1 LED - Green
Out9  = 0		'PWM1 LED - Red
Out10 = 0		'PWM2 LED - Green
Out11 = 0		'PWM2 LED - Red
Out12 = 0		'Relay1 LED - Red
Out13 = 0		'Relay1 LED - Green
Out14 = 0		'Relay2 LED - Red
Out15 = 0		'Relay2 LED - Green

p1_x = 127		'Port 1, X-axis on Joystick
p2_x = 127		'Port 2, X-axis on Joystick
'p3_x = 127		'Port 3, X-axis on Joystick
'p4_x = 127		'Port 4, X-axis on Joystick

p1_y = 127		'Port 1, Y-axis on Joystick
p2_y = 127		'Port 2, Y-axis on Joystick
'p3_y = 127		'Pot 3, Y-axis on Joystick
'p4_y = 127		'Port 4, Y-axis on Joystick

p1_wheel = 127	'Port 1, Wheel on Joystick
p2_wheel = 127	'Port 2, Wheel on Joystick
'p3_wheel = 127	'Port 3, Wheel on Joystick
'p4_wheel = 127	'Port 4, Wheel on Joystick

'p1_aux = 127	'Port 1, Aux Analog
'p2_aux = 127	'Port 2, Aux Analog
'p3_aux = 127	'Port 3, Aux Analog
'p4_aux = 127	'Port 4, Aux Analog

'--added for 2001 
sensor1 = 127
sensor2 = 127
sensor3 = 127
sensor4 = 127
p2_aux = 127


'JogReady = 1


'========== PBASIC - MASTER uP INITIALIZATION ROUTINE ========================
'=============================================================================
'  DO NOT CHANGE THIS!  DO NOT MOVE THIS!
'  The init routine sends 5 bytes to the Master uP, defining which data bytes to receive.
'  1)  Collect init.
'  2)  Lower the COMA line, which is the clk line for the shift out command.
'  3)  Lower COMB line to tell pic that we are ready to send init data.
'  4)  Wait for pic to lower the COMC line, signaling pic is ready for data.
'  5)  Now send out init dat to pic, all 5 bytes.
'  6)  Now set direction and levels for the COMA and COMB pins.

tempA		CON	c_p3_x <<1 + c_p4_x <<1 + c_p1_x <<1 + c_p2_x <<1 + c_rc_swB
dataInitA	CON	tempA <<1 + c_rc_swA <<1 + c_oi_swB <<1 + c_oi_swA
tempB		CON	c_sensor4 <<1 + c_sensor3 <<1 + c_p1_y <<1 + c_p2_y <<1 + c_sensor2
dataInitB	CON	tempB <<1 + c_sensor1 <<1 + c_packet_num <<1 + c_PB_mode
tempC		CON	c_batt_volt <<1 + c_sensor7 <<1 + c_p1_wheel <<1 + c_p2_wheel <<1 + c_sensor6
dataInitC	CON	tempC <<1 + c_sensor5 <<1 + c_p3_y <<1 + c_p4_y
tempD		CON	c_res01 <<1 + c_delta_t <<1 + c_p3_aux <<1 + c_p4_aux <<1 + c_p1_aux
dataInitD	CON	tempD <<1 + c_p2_aux  <<1 + c_p3_wheel <<1 + c_p4_wheel

Output	COMA
low		COMA
low		COMB
Wait_init:	if IN3 = 1 then Wait_init:
Shiftout	COMB,COMA,1, [dataInitA,dataInitB,dataInitC,dataInitD,dataInitVolt]
Input		COMA
high		COMB



'Initialize Scratchpad ram with default (safe) values:

PUT s_oi_swA, 0
PUT s_oi_swB, 0
PUT s_rc_swA, 0
PUT s_rc_swB, 0
PUT s_p2_x, 127
PUT s_p1_x, 127
PUT s_p4_x, 127
PUT s_p3_x, 127
PUT s_PB_mode, 0
PUT s_packet_num, 0
PUT s_sensor1, 127
PUT s_sensor2, 127
PUT s_p2_y, 127
PUT s_p1_y, 127
PUT s_sensor3, 127
PUT s_sensor4, 127
PUT s_p4_y, 127
PUT s_p3_y, 127
PUT s_sensor5, 127
PUT s_sensor6, 127
PUT s_p2_wheel, 127
PUT s_p1_wheel, 127
PUT s_sensor7, 127
PUT s_sensor8, 127
PUT s_p4_wheel, 127
PUT s_p3_wheel, 127
PUT s_p2_aux, 127
PUT s_p1_aux, 127
PUT s_p4_aux, 127
PUT s_p3_aux, 127
PUT s_delta_t, 127
PUT s_res01, 127
PUT s_pwm1, 127
PUT s_relayA, 127
PUT s_pwm2, 127
PUT s_relayB, 127
PUT s_pwm3, 127
PUT s_pwm4, 127
PUT s_pwm5, 127
PUT s_pwm6, 127
PUT s_pwm7, 127
PUT s_pwm8, 127
PUT s_pwm9, 127
PUT s_pwm10, 127
PUT s_pwm11, 127
PUT s_pwm12, 127
PUT s_pwm13, 127
PUT s_pwm14, 127
PUT s_pwm15, 127
PUT s_pwm16, 127
PUT s_ramp_seek, RAMP_NO_SEEK  'initialize mode 
PUT s_lift_seek, LIFT_NO_SEEK  'initialize mode 
'PUT s_rampAvg, 127

'etc...


'========== MAIN LOOP ========================================================
'=============================================================================

MainLoop:

Gosub GetInputs

if DEBUG_ENABLE = 0 then end_cls
'debug CLS
end_cls

'---------- Blink BASIC RUN LED ----------------------------------------------
Toggle 7			'Basic Run LED on the RC is toggled ON/OFF every loop.

' To make the same implicit mappings that the default code used to by writing
' the input vars directly to the output stream, you could simply map the following
' vars in scratchpad memory... but I'll just chose to leave the default values (off). 
' [ p3_y,  p4_y,  p1_x,  p2_x,  p3_x,  p4_x,  p1_wheel,p2_wheel,p3_wheel,p4_wheel,127,    127,    127,    127 ]
' [(PWM3),(PWM4),(PWM5),(PWM6),(PWM7),(PWM8),(PWM9),  (PWM10), (PWM11), (PWM12), (PWM13),(PWM14),(PWM15),(PWM16) ]


'=============================================================================
'========== PERFORM OPERATIONS ===============================================
'=============================================================================
'  Add your custom code here.
'  Delete any of the following sections below (except for Output Data) as desired.


'----------------
Gosub DriveSystem 
'----------------



'-------- Servomatronical -----------
'<deleted>


'----------- LIFT & RAMP ------------
gosub SelectModes 

'service the chosen ramp mode
gosub doRamp

'service the chosen lift mode
gosub doLift
'------------------------------------



'---------- Deployment of the Wings and Doors --------------------

GET s_p1_y, p1_y  'the "analog buttons", 127 +-64 indicates being pressed. 
GET s_p1_x, p1_x
'debug "p1_x=", dec p1_x, " y=", dec p1_y, CR

'--Doors
PUT s_pwm5, 127  'stopped by default

if (p1_sw_aux1 = 1) OR (p2_sw_aux2 = 1) then open_doors
if (p1_sw_aux2 = 1) then close_doors

goto doors_done

close_doors:
PUT s_pwm5, DOORS_CLOSE_SPEED
goto doors_done:

open_doors:
PUT s_pwm5, DOORS_OPEN_SPEED
goto doors_done:

doors_done:


'--Wings...never close with software
relay3_fwd = 0
relay3_rev = 0 'stopped by default

if (p1_x < 127-64) or (p1_x > 127+64) or (p2_sw_trig=1) then open_wings
goto wings_done

open_wings:
relay3_fwd = 1
goto wings_done:

wings_done:

'---------- DinnerwareOfTheMovingSort (forks) ----------
relay2_fwd = p4_sw_aux1  
relay2_rev = p4_sw_aux2  

PUT s_relayA, relayA  'all relay stuff done: write the relay output 

'--------------------------------------------------------


'---------- the Beatty (pneumatic (air) cylinder on arms) -------------------------------
'sdt: When either open or close is pressed, activate the solenoid in the open or close
'     direction and also run the pump.  Always run the pump forward when either button pressed.
relay6_fwd = 0   'Yellow - the solenoid
relay6_rev = 0
relay7_fwd = 0   'Grey - the pump
relay7_rev = 0

if (p1_y > 127+64) then beatty_FWD_REV
if (p1_y < 127-64) then beatty_FWD_FWD
goto beatty_done

beatty_FWD_REV:
relay6_rev	= 1	'yellow-the solenoid (reverse)
relay7_fwd = 1	'grey-the pump (fowrard only)
goto beatty_done

beatty_FWD_FWD:
relay6_fwd	= 1	'yellow-the solenoid (forward)
relay7_fwd = 1	'grey-the pump (forward only)
goto beatty_done

beatty_done:

'turn on THE light
relay8_fwd = 1
PUT s_relayB, relayB  'all relay B stuff done: write the relay output 


'----------------
gosub AlignBridge  'just LEDs at this point...





'---------- Feedback LEDs for PWM1, PWM2 -------------------------------------

'K: for analog (byte) values, always GET ram vars before using, and always
'PUT the results back (only if the value was updated)

'<removed> nonk

'---------- Feedback LEDs for Relay1, Relay2 ---------------------------------

'<removed> nonk



'----- JOG side-step code -------------------------------------
'run 1  'this line can be inserted to enable sidestep (jog)
'       routines if they are loaded in bank 1 of memory
'       (this is bank 0). 
'if banks don't seem to work.. maybe try preferences/editor/download mode. 
'--------------------------------------------------------------


'========== OUTPUT DATA ======================================================

Gosub RecallOutputs 'retrieve the saved values from memory. 
Gosub WriteOutputs  'the normal end-of-loop output write. 
Goto MainLoop:
Stop


'=============================================================================
' Subroutines 
'=============================================================================

'--------------------------subroutine (level 1) (4 is max) 
DriveSystem:

'-------- code for single-stick drive -----------
'(make this a gosub, scratchpad mem works like parameter passing)

' Read the original input values you need (as the code grows, their registers may 
' have been modified by some intervening code) into temporary variables (given nice
' meaningful names), do the computations, and store the output values to where
' they will be used. 

GET s_p2_y, p2_y
GET s_p2_x, p2_x
'debug "p2_x=", dec p2_x, " y=", dec p2_y, CR

'-------- Dead ZoneinizerCreatorToTheCore -----------

'create a bit of a DEAD ZONE on the X axis.. easier to drive straight. 
if p2_x > 127+DRIVE_DEADZONE or p2_x < 127-DRIVE_DEADZONE then p2_x_outofzone
'else
 p2_x = 127 'stick the input back to center
p2_x_outofzone:

'create a bit of a DEAD ZONE on the Y axis.. less jumpy
if p2_y > 127+DRIVE_DEADZONE or p2_y < 127-DRIVE_DEADZONE then p2_y_outofzone
'else
 p2_y = 127 'stick the input back to center
p2_y_outofzone:


'-------- Single Stick Drive -----------

stick_mode:
'if in single stick mode, set motor speeds according to the combined x/y equations.
'manual p.31 (the 2000s are to avoid negative numbers)
   tmp2 = (((((2000 + p2_y - p2_x + 127) Min 2000 Max 2254) - 2000)) MAX 254)
   tmp1  = (((((2000 + p2_y + p2_x - 127) Min 2000 Max 2254) - 2000)) MAX 254)

'---- brian's new test
'tmp1 = (((1000 + (p2_x - 128)/2 + (p2_y - 128) + 128) MIN 1000 MAX 1254) - 1000)
'tmp2 = (((1000 + (128 - p2_x)/2 + (p2_y - 128) + 128) MIN 1000 MAX 1254) - 1000)


'-------- Quite Simple a-turbonic Motion -----------

if (p2_sw_top = 1) OR (p2_sw_trig = 1) then turbo1
'else, scale speeds down
   tmp2 = ((tmp2 * DRIVE_SCL/100) + DRIVE_CON MAX 254)
   tmp1  = ((tmp1 * DRIVE_SCL/100) + DRIVE_CON MAX 254)
turbo1:

' to change pwm mappings, simply write to the appropriate location. 
PUT s_pwm2,  tmp1  'R front wheel
PUT s_pwm3,  tmp1  'R back wheel
PUT s_pwm9,  tmp2  'L front wheel 
PUT s_pwm10, tmp2  'L back wheel 

return


'--------------------------subroutine
AlignBridge:
'--------- Align to Bridge with optical sensors ----------
out11 =~ rc_sw15
out10 =~ rc_sw16

'debug ? p2_wheel

if (p2_wheel < ENABLE_AUTOALIGN_THRESHHOLD) then doneAlign
if ((p2_x > 127+DRIVE_DEADZONE) or (p2_x < 127-DRIVE_DEADZONE) or (p2_y > 127+DRIVE_DEADZONE) or (p2_y < 127-DRIVE_DEADZONE)) then doneAlign

'if (p3_sw_aux1 = 1 and rc_sw15  = 0 and rc_sw16 = 1) then alignRight
'if (p3_sw_aux1 = 1 and rc_sw15  = 1 and rc_sw16 = 0) then alignLeft
'if (rc_sw15  = 1 and rc_sw16 = 0) then alignLeft  'No button press
if (rc_sw15  = 0 and rc_sw16 = 0) then alignBoth  'No button press
if (rc_sw15  = 1 and rc_sw16 = 0) then alignLeft  'No button press
if (rc_sw15  = 0 and rc_sw16 = 1) then alignRight  'No button press
'else
goto doneAlign 


alignLeft:
'(?does this comment really mean backward since we "back" up to the bridge)
PUT s_pwm2,  ALIGN_FORWARD_SPEED 'Left Wheels Forward 
PUT s_pwm3,  ALIGN_FORWARD_SPEED

PUT s_pwm9,  ALIGN_REVERSE_SPEED 'Right Wheels Reverse of left
PUT s_pwm10, ALIGN_REVERSE_SPEED
goto doneAlign


alignRight:
PUT s_pwm2,  ALIGN_REVERSE_SPEED'Left Wheels reverse of right
PUT s_pwm3,  ALIGN_REVERSE_SPEED

PUT s_pwm9,  ALIGN_FORWARD_SPEED 'Right Wheels Forward
PUT s_pwm10, ALIGN_FORWARD_SPEED

'goto doneAlign

alignBoth:
goto doneAlign

doneAlign:

return



'--------------------------subroutine
SelectModes:  'for LIFT & RAMP

'---------- Tail / Lift position mode selection ----------
'GET s_oi_swX  '(just to show where this would go if we ever aliased switches) 
GET s_sensor1, sensor1 
GET s_sensor2, sensor2 

'debug "sensor1=", dec sensor1, " sensor2=", dec sensor2, CR

'----- RAMP mode arbitration (later lines override earlier lines)
's_ramp_seek is the 'mode', which is the angle, or 0 for manual. 

'-- (auto arch has to be lowest precedence to not mask any button presses)
'if lift above threshold, and ramp in arch zone 
if (sensor1 > LIFT_ARCH_POINT) and (sensor2 > RAMP_ARCH_ZONE) then ramp_arch
goto no_ramp_arch:

ramp_arch: 
PUT s_ramp_seek, RAMP_ARCH_SEEK  
'              "follow mode" --> This could conceivably be computed
'as a function of the lift position rather than being a constant...
'e.g. if lift is +up and ramp is +down (which it's not, currently) 
'match % of way ramp is into arch zone with % that lift is between 
'balance and top points. 
'PUT s_ramp_seek, (((sensor1 - LIFT_BALANCE_SEEK) / (LIFT_TOP - LIFT_BALANCE_SEEK)) * (RAMP_ARCH_SEEK - RAMP_LEVEL_SEEK)) + RAMP_LEVEL_SEEK
'(fix the various discrete math problems...) 
no_ramp_arch: 

'(THIS 'if' line should be removed if we use "follow mode")
'if (ramp in arch zone and lift below threshold) 
if ((sensor2 > RAMP_ARCH_ZONE) and (sensor1 < LIFT_ARCH_POINT)) then ramp_level

'if level button pressed... 
'p2_sw_aux1 is the joystick left trigger
if (p3_sw_aux1 = 1) or (p2_sw_aux1 = 1) then ramp_level
goto no_ramp_level 

ramp_level: 
PUT s_ramp_seek, RAMP_LEVEL_SEEK
no_ramp_level: 
'--


'if ramp_up button pressed, set up_seek mode
if p3_sw_aux2 = 1 then ramp_up:
goto no_ramp_up:

ramp_up:
PUT s_ramp_seek, RAMP_UP_SEEK
no_ramp_up: 



'if a manual button (or... add any list of things with higher precidence here)
if (p4_sw_trig = 1) or (p4_sw_top = 1) or (p2_aux > 127+RAMP_JOY_DEADZONE) or (p2_aux < 127-RAMP_JOY_DEADZONE) then manual_mode
goto no_manu


manual_mode:
PUT s_ramp_seek, RAMP_NO_SEEK  'manual mode
no_manu:

'else...
'STAY in current mode (implicit.. but leave this comment as a placeholder) 



'----- LIFT mode arbitration (later lines override earlier lines)
's_lift_seek is the 'mode', which is either the height, or 0-1 for manual. 

'if lift-balance-position button pressed, set balance_lift mode
if p1_sw_trig = 1 then balance_lift:
goto no_balance_lift:

balance_lift:
PUT s_lift_seek, LIFT_BALANCE_SEEK
no_balance_lift: 


'if lift-ready-position button pressed, set ready_lift mode
'if p1_sw_aux2 = 1 then ready_lift:
goto no_ready_lift:

ready_lift:
PUT s_lift_seek, LIFT_READY_SEEK
no_ready_lift: 


'if lift-freefall button pressed, set freefall_lift mode
if p1_sw_top = 1 then freefall_lift:
goto no_freefall_lift:

freefall_lift:
PUT s_lift_seek, LIFT_FREEFALL  'overrides (stops) auto-seek
no_freefall_lift: 


'if a manual button (or... add any list of things with higher precidence here)
if (p3_sw_trig = 1) or (p3_sw_top = 1) then manual_mode_lift
goto no_manu_lift

manual_mode_lift:
PUT s_lift_seek, LIFT_NO_SEEK  'manual mode: overrides seek & freefall. 
no_manu_lift:

'else...
'STAY in current mode (implicit.. but leave this comment as a placeholder) 

'--------- Lift Balance LEDs ----------
out8 =~ rc_sw3 
out9 =~ rc_sw1

if (rc_sw3 = 1 and rc_sw1 = 0) then pullLED
if (rc_sw3 = 0 and rc_sw1 = 1) then pushLED

pullLED:
'out8 =~ rc_sw3
'out9 = rc_sw1
goto balanceDone

pushLED:
'out8 =~ rc_sw1
'out9 = rc_sw3
goto balanceDone

balanceDone:
'--------------------------------

return



'--------------------------subroutine
doLift: 'this little branch routine makes it easier to keep the
        'mode precidence logic independent of the mode implementation. 

GET s_lift_seek, tmp1

'GET s_sensor1, sensor1 'the current height of the lift
'debug "target=", dec tmp1, " current=", dec sensor1, CR

if tmp1 = LIFT_NO_SEEK then goManualLift
'else
if tmp1 = LIFT_FREEFALL then goFreefallLift
'else
gosub doSeekLift
goto doLift_done

goManualLift:
gosub doManualLift
goto doLift_done

goFreefallLift:
gosub doFreefallLift

doLift_done:
return 


'--------------------------subroutine
doManualLift: 
PUT s_pwm7, 127  'lift is stopped unless a control is pressed

'GET s_oi_swA, oi_swA  '(just to show where this would go if we ever aliased switches) 
'debug "p3_sw_trig=", dec p3_sw_trig, " top=", dec p3_sw_top, " sensor1=", dec sensor1, CR

if (p3_sw_trig = 1) then lift_up
if (p3_sw_top  = 1) then lift_down
goto lift_done

lift_down:
PUT s_pwm7, LIFT_DOWN_SPEED
goto lift_done

lift_up:
PUT s_pwm7, LIFT_UP_SPEED
goto lift_done

lift_done:
return


'--------------------------subroutine  (verified 3/3) 
doFreefallLift: 
PUT s_pwm7, 127  'lift is stopped unless triggered 
GET s_sensor1, sensor1 'the current height of the lift

'GET s_oi_swA, oi_swA  '(just to show where this would go if we ever aliased switches) 
'debug "p1_sw_aux2=", dec p1_sw_aux2, " rc_sw3=", dec rc_sw3, " sensor1=", dec sensor1, CR

if (rc_sw3 = 1) and (sensor1 > LIFT_DOWN_SEEK) then lift_fall
goto lift_nofall

lift_fall:
PUT s_pwm7, LIFT_FREEFALL_SPEED
goto lift_done

lift_nofall:
return


'--------------------------subroutine
doSeekLift: 'the calling code takes care of stopping this if necessary 

GET s_lift_seek, tmp1  'tmp1 is the angle to seek to. 
GET s_sensor1, sensor1 'the current height of the lift

LIFT_DEADZONE CON 3  'this is intimately tied to the feedback lines right here:

'sensor Down is Decreacing values
'motor Down is Lower than 127
if sensor1 < tmp1 - LIFT_DEADZONE then liftup
if sensor1 > tmp1 + LIFT_DEADZONE then liftdown
'else
PUT s_pwm7, 127  'stop
goto seekl_done

liftup:
PUT s_pwm7, 127+30
goto seekl_done

liftdown:
PUT s_pwm7, 127-30
goto seekl_done

seekl_done: 
return 



'--------------------------subroutine
doRamp: 'this little branch routine makes it easier to keep the
        'mode precidence logic independent of the mode implementation. 

GET s_ramp_seek, tmp1

'GET s_sensor2, sensor2 'the current angle of the ramp
'debug "target=", dec tmp1, " current=", dec sensor2, CR

if tmp1 = RAMP_NO_SEEK then goManual
'else
gosub doSeekRamp
goto doRamp_done

goManual:
gosub doManualRamp

doRamp_done:
return 


'--------------------------subroutine
doManualRamp: 
'---------- ScorpionDeathPinionOfDoom (tail = ramp) --------
'if (abs(pot1 - pot2) >= 5) then ramp_done_manu
'PUT s_rampAvg, ((pot1 + pot2) / 2)

PUT s_pwm8, 127  'ramp is stopped unless a control is pressed

'GET s_oi_swB, oi_swB  '(just to show where this would go if we ever aliased switches) 
'debug "p4_sw_trig=", dec p4_sw_trig, " top=", dec p4_sw_top, " sensor2=", dec sensor2, CR

if (p2_aux > 127+RAMP_JOY_DEADZONE) or (p2_aux < 127-RAMP_JOY_DEADZONE) then joy_ramp
'else
goto no_joy_ramp

joy_ramp:
'if going up and > RAMP_UP_LIMIT and not in Software Override Mode
if (p2_aux < 127) AND (sensor2 <= RAMP_UP_LIMIT) AND (p2_wheel > DISABLE_SOFTARE_THRESHOLD) then no_joy_ramp
PUT s_pwm8, p2_aux
'debug ? p2_aux
goto ramp_done_manu

no_joy_ramp:

if (p4_sw_trig = 1) then ramp_down_manu
if (p4_sw_top  = 1) AND (sensor2 > RAMP_UP_LIMIT) then ramp_up_manu
goto ramp_done_manu

ramp_down_manu:
PUT s_pwm8, RAMP_DOWN_SPEED_FAST
goto ramp_done_manu

ramp_up_manu:
PUT s_pwm8, RAMP_UP_SPEED_FAST
goto ramp_done_manu

ramp_done_manu:

return


'--------------------------subroutine
doSeekRamp: 'the calling code takes care of stopping this if necessary 

GET s_ramp_seek, tmp1  'tmp1 is the angle to seek to. 
GET s_sensor2, sensor2 'the current angle of the ramp

'sensor Down is Increacing values
'motor Down is Higher than 127
if sensor2 < tmp1 - RAMP_DEADZONE then rampdown
if sensor2 > tmp1 + RAMP_DEADZONE then rampup
'else
PUT s_pwm8, 127  'stop
goto seekr_done

rampdown:
if sensor2 < (tmp1 - RAMP_DOWN_SLOW_SPEED_ZONE) then rampdownfast
'else RAMP is close to target...run it slow (or real slow)
if tmp1 = RAMP_UP_SEEK then rampdownrealslow 'UP position is in the air...run real slow
'else we are not seeking to the UP position...run normal slow (strong enought to lift the bot)
PUT s_pwm8, RAMP_DOWN_SPEED_SLOW
goto seekr_done

'sdt: Real slow is needed for positions in the air.  Without the added force of lifting
'     the robot the tail will just oscillate without a real slow speed.
rampdownrealslow:
PUT s_pwm8, RAMP_DOWN_SPEED_REAL_SLOW
goto seekr_done

rampup:
if sensor2 > (tmp1 + RAMP_UP_SLOW_SPEED_ZONE) then rampupfast
'else RAMP is close from target...run it slowh
PUT s_pwm8, RAMP_UP_SPEED_SLOW
goto seekr_done

'sdt: Ramp is outside the slow zone...we are not close to the target
rampdownfast:
PUT s_pwm8, RAMP_DOWN_SPEED_FAST
goto seekr_done

rampupfast:
PUT s_pwm8, RAMP_UP_SPEED_FAST
goto seekr_done

seekr_done: 
return 


'--------------------------subroutine
GetInputs:

'---------- Serin Command - Get Data from Master uP --------------------------
'  Construct the "serin" command using the following rules:
'  1) There must be one variable for every input defined in the "Define Constants for Init" section.
'  2) The order must match the order in the EXAMPLE SERIN COMMAND below.
'  3) The total number of all variables may not exceed 26.
'  4) Only use one "Serin" command.
'  5) The Serin command must occupy one line.
'
'  If you see a BASIC INIT ERR on the Robot Controller after programming and pressing RESET, then
'  there is a problem with the Serin command below.  Check the number of variables.  A BASIC INIT ERR
'  will not occur if you have the variables in the wrong order, however your code will not work correctly.
'
'  EXAMPLE SERIN COMMAND
'  This example exceed the 26 variable limit and is not on one line:
'
'  Serin COMA\COMB, INBAUD, [oi_swA,oi_swB,rc_swA,rc_swB,p2_x,p1_x,p4_x,p3_x,PB_mode,packet_num,sensor1,
'				     sensor2,p2_y,p1_y,sensor3,sensor4,p4_y,p3_y,sensor5,sensor6,p2_wheel,p1_wheel,
'				     sensor7,sensor8,p4_wheel,p3_wheel,p2_aux,p1_aux,p4_aux,p3_aux,delta_t,res01]
'
'   Serin COMA\COMB, INBAUD, [oi_swA,oi_swB,rc_swA,rc_swB,p2_x,p1_x,p4_x,p3_x,PB_mode,p2_y,p1_y,p4_y,p3_y,p2_wheel,p1_wheel,p4_wheel,p3_wheel]
'  (above is the default)

   Serin COMA\COMB, INBAUD, [oi_swA,oi_swB,rc_swA,rc_swB,p2_x,p1_x,sensor1,sensor2,p2_y,p1_y,sensor3,sensor4,p2_wheel,p1_wheel,p2_aux]

'WS01 inputs used/not used: 
'--delta from original defaults: 
'oi_swA -keep
'oi_swB -keep
'rc_swA -keep
'rc_swB -keep
'p2_x -keep, drive
'p1_x -might use
'p4_x -del
'p3_x -del
'PB_mode, -del won't use
'sensor1 -add, pot for lift
'sensor2 -add, pot for ramp 
'p2_y -keep, drive 
'p1_y -might use
'sensor3 -add, might use for redundant pot for tail
'sensor4 -add, might use
'p4_y -del
'p3_y -del
'p2_wheel -keep (electrically mapped to x axis of 2nd joystick) 
'p1_wheel -might use 
'p4_wheel -del
'p3_wheel -del
'p2_aux -add (electrically mapped to y axis of 2nd joystick)


'K: store ram vars in an un-aliased scratchpad location. 

PUT s_oi_swA, oi_swA
PUT s_oi_swB, oi_swB
PUT s_rc_swA, rc_swA
PUT s_rc_swB, rc_swB
PUT s_p2_x, p2_x
PUT s_p1_x, p1_x  'store value of p1_x (in location s_p1_x) 
'PUT s_p4_x, p4_x
'PUT s_p3_x, p3_x
'PUT s_PB_mode, PB_mode
PUT s_p2_y, p2_y
PUT s_p1_y, p1_y
'PUT s_p4_y, p4_y
'PUT s_p3_y, p3_y
PUT s_p2_wheel, p2_wheel
PUT s_p1_wheel, p1_wheel
'PUT s_p4_wheel, p4_wheel
'PUT s_p3_wheel, p3_wheel

'--added for 2001 
PUT s_sensor1, sensor1
PUT s_sensor2, sensor2
PUT s_sensor3, sensor3
PUT s_sensor4, sensor4
PUT s_p2_aux, p2_aux


'...add any others as needed. 
'debug "IN p1_sw_aux2=", dec p1_sw_aux2, " rc_sw3=", dec rc_sw3, " sensor1=", dec sensor1, CR

'brianthecrack
'debug ? sensor1
'debug ? sensor2

'debug ? p2_x
'debug ? p2_y
'debug CR

return




'--------------------------subroutine
RecallOutputs:

'debug ? p1_sw_trig
'debug ? p2_sw_trig
'debug ? left_wheel
'debug ? right_wheel
'debug CR

return


'--------------------------subroutine
'========== OUTPUT DATA ====================================================
'=============================================================================

WriteOutputs:

'do the final output value GETs before writing to outputs. 

'GET s_pwm1, pwm1
GET s_relayA, relayA 
GET s_pwm2, pwm2
GET s_relayB, relayB
GET s_pwm3, pwm3
'GET s_pwm4, pwm4
GET s_pwm5, pwm5
GET s_pwm6, pwm6
GET s_pwm7, pwm7
GET s_pwm8, pwm8
GET s_pwm9, pwm9
GET s_pwm10, pwm10
GET s_pwm11, pwm11
GET s_pwm12, pwm12
GET s_pwm13, pwm13
GET s_pwm14, pwm14
GET s_pwm15, pwm15
GET s_pwm16, pwm16

'debug ? pwm2
'debug ? pwm3
'debug ? pwm9
'debug ? pwm10
'debug CR

'debug ? relay6_rev
'debug ? relay6_fwd
'debug ? relay7_rev
'debug ? relay7_fwd



'  The Serout line sends data to the Output uP.  The Output uP passes this to each PWM 1-16
'  and Relay 1-8.  The Output uP will not output data if there is no communication with the
'  Operator Interface or if the Competition Mode is Disabled.  Do not delete any elements
'  from the Serout array.  Set unused PWM outputs to 127.  Set unused relay outputs to 0.
'
'  Serout USERCPU, OUTBAUD, [255,255,pwm1,relayA,pwm2,relayB,p3_y,p4_y,p1_x,p2_x,p3_x,p4_x,p1_wheel,p2_wheel,p3_wheel,p4_wheel,127,127,127,127]
'  Serout USERCPU, OUTBAUD, [255,255,(PWM1),relayA,(PWM2),relayB,(PWM3),(PWM4),(PWM5),(PWM6),(PWM7),(PWM8),(PWM9),(PWM10),(PWM11),(PWM12),(PWM13),(PWM14),(PWM15),(PWM16)]

   Serout USERCPU, OUTBAUD, [255,255, NO_PWM, relayA, pwm2, relayB, pwm3,  NO_PWM,  pwm5,  pwm6,  pwm7,  pwm8,  pwm9,  pwm10,  pwm11,  pwm12,  pwm13,  pwm14,  pwm15,  pwm16]

return
  